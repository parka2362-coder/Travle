<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>랜덤 세계 여행 - 한국 근교편</title>
    <!-- Three.js & Tailwind CSS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@100;300;400;500;700&display=swap');
        
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Noto Sans KR', sans-serif;
            background-color: #050510;
            color: white;
            touch-action: none;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            background: radial-gradient(circle at center, #1a1a2e 0%, #000000 100%);
        }

        #ui-layer {
            position: absolute;
            z-index: 10;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
        }

        .interactive-element { pointer-events: auto; }

        /* --- 2D 비행기 아이콘 스타일 (SVG) --- */
        #css-plane {
            position: absolute;
            width: 48px;
            height: 48px;
            z-index: 50;
            transform-origin: center center;
            display: none;
            pointer-events: none;
            filter: drop-shadow(0 4px 6px rgba(0,0,0,0.5)); 
            will-change: transform, left, top;
        }

        /* --- 팝업 카드 스타일 --- */
        .pop-panel {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            color: #1f2937;
            border-radius: 1.25rem;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.6);
            opacity: 0;
            transition: all 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            border: 1px solid rgba(255,255,255,0.8);
            
            position: absolute;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            
            /* 모바일 기본: 중앙 */
            top: 55%; 
            left: 50%;
            transform: translate(-50%, -40%);
            width: 80%;
            max-width: 20rem;
            aspect-ratio: 5 / 3;
        }

        /* 데스크톱(md 이상) 레이아웃 */
        @media (min-width: 768px) {
            .pop-panel {
                top: 50%;
                left: 75%; 
                right: auto;
                transform: translate(-50%, -50%) scale(0.9);
                max-width: 20rem;
                aspect-ratio: auto;
                min-height: auto;
            }
            
            .pop-panel.show {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }
        
        @media (max-width: 767px) {
            .pop-panel.show {
                transform: translate(-50%, -50%);
                opacity: 1;
            }

            #ui-layer {
                overflow-y: auto;
                pointer-events: auto;
                padding-bottom: 2rem;
            }

            .destination-board,
            .rank-board {
                position: relative;
                top: auto;
                left: auto;
                right: auto;
                transform: none;
                width: min(92%, 22rem);
                max-height: none;
                margin: 1rem auto 0;
            }
        }

        /* --- 여행지 리스트 보드 스타일 --- */
        .destination-board,
        .rank-board {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 11rem; 
            max-height: 55vh;
            
            background: rgba(20, 20, 35, 0.6);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 1rem;
            padding: 1.25rem;
            
            display: flex;
            flex-direction: column;
            
            opacity: 1;
            transition: transform 0.8s cubic-bezier(0.22, 1, 0.36, 1), opacity 0.8s ease;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        .destination-board.slide-out {
            transform: translate(-200%, -50%);
            opacity: 0;
            pointer-events: none;
        }

        .destination-board { left: 2rem; }
        .rank-board { right: 2rem; }

        .board-title {
            font-size: 0.8rem;
            font-weight: 700;
            color: #60a5fa;
            margin-bottom: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 0.5rem;
        }

        .board-list {
            overflow-y: auto;
            padding-right: 0.5rem;
        }

        .board-list::-webkit-scrollbar { width: 3px; }
        .board-list::-webkit-scrollbar-track { background: rgba(255,255,255,0.05); }
        .board-list::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 2px; }

        .board-item {
            display: flex;
            justify-content: space-between;
            font-size: 0.75rem;
            padding: 0.35rem 0;
            color: rgba(255, 255, 255, 0.8);
            border-bottom: 1px dashed rgba(255, 255, 255, 0.05);
        }
        .board-item:last-child { border-bottom: none; }
        .board-item span.city { font-weight: 500; color: white; }
        .board-item span.country { font-size: 0.7rem; color: #9ca3af; }

        /* --- 버튼 스타일 --- */
        .btn-main {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(37, 99, 235, 0.4);
            transition: all 0.3s;
            border: none;
            font-family: 'Noto Sans KR', sans-serif;
            letter-spacing: -0.02em;
        }
        .btn-main:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 6px 20px rgba(37, 99, 235, 0.6);
        }
        .btn-main:active { transform: translateY(1px); }
        .btn-main:disabled {
            background: #94a3b8;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .loader {
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top: 2px solid #fff;
            width: 14px;
            height: 14px;
            animation: spin 1s linear infinite;
            display: none;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        .ui-header {
            position: absolute;
            top: 1.5rem; 
            left: 0;
            width: 100%;
            text-align: center;
        }
        
        .ui-footer {
            position: absolute;
            bottom: 4rem; 
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            transition: all 0.5s ease;
        }

        .result-mode .ui-footer {
            @media (min-width: 768px) {
                left: 75%;
                width: auto; 
                transform: translateX(-50%); 
            }
        }
    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <!-- 2D 비행기 SVG 아이콘 -->
        <svg id="css-plane" viewBox="0 0 24 24" fill="#38bdf8" xmlns="http://www.w3.org/2000/svg">
            <path d="M21 16v-2l-8-5V3.5c0-.83-.67-1.5-1.5-1.5S10 2.67 10 3.5V9l-8 5v2l8-2.5V19l-2 1.5V22l3.5-1 3.5 1v-1.5L13 19v-5.5l8 2.5z"/>
        </svg>

        <header id="main-header" class="ui-header interactive-element">
            <h1 class="text-2xl md:text-4xl font-light text-white drop-shadow-lg tracking-tighter">
                여미계 새 여행지는?!
            </h1>
            <p class="text-white mt-2 text-sm font-normal tracking-wide opacity-100 drop-shadow-md">
                여<span class="text-xs opacity-80">(<span class="relative inline-block">자<span class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-red-500 font-bold text-base pointer-events-none">X</span></span> 행)</span>에 미<span class="text-xs opacity-80">(친)</span> 계<span class="text-xs opacity-80">(모임)</span> 어디로 갈까요~?
            </p>
        </header>

        <!-- 후보 리스트 보드 -->
        <div id="destination-board" class="destination-board interactive-element flex">
            <div class="board-title">Travel Candidates</div>
            <div id="board-list-container" class="board-list"></div>
        </div>
        <div id="rank-board" class="rank-board interactive-element flex">
            <div class="board-title">Pick Ranking</div>
            <div id="rank-list-container" class="board-list"></div>
        </div>

        <!-- 결과 팝업 -->
        <div id="result-card" class="pop-panel p-5 interactive-element text-center hidden">
            <div class="mb-2 text-blue-600 font-bold tracking-widest text-[10px] uppercase">DESTINATION FOUND</div>
            <h2 id="city-name" class="text-2xl font-bold mb-0.5 text-gray-900 tracking-tight">Seoul</h2>
            <h3 id="country-name" class="text-sm text-gray-500 mb-2 font-medium tracking-tight">South Korea</h3>
            
            <p id="description" class="text-xs text-gray-600 leading-relaxed mb-2 border-t border-gray-200 pt-2 font-light w-full px-2">
                설명 텍스트가 여기에 들어갑니다.
            </p>
            
            <div class="flex justify-center items-center space-x-1.5 text-[10px] text-white font-medium bg-gray-900 rounded-full py-1 px-3 mt-3 mx-auto w-fit shadow-sm tracking-wide">
                <span>📍</span>
                <span id="coords">37.56° N, 126.97° E</span>
            </div>
        </div>

        <!-- 버튼 -->
        <div id="main-footer" class="ui-footer interactive-element">
            <button id="spin-btn" class="w-auto font-bold py-2 px-6 rounded-full text-sm btn-main flex justify-center items-center gap-2 shadow-lg hover:shadow-xl">
                <div id="btn-loader" class="loader"></div>
                <span id="btn-text">🎲 여행지 뽑기</span>
            </button>
        </div>
    </div>

    <script>
        // --- 설정 ---
        const CONFIG = {
            textureUrl: 'https://unpkg.com/three-globe/example/img/earth-blue-marble.jpg',
            cameraZ: 16,
            earthRadius: 3.5,
            spinSpeed: 0.001,
            maxSpinSpeed: 0.5,
            acceleration: 0.02,
            colors: {
                pin: 0xff3366,
                pinEmissive: 0xaa0033
            }
        };

        const KOREA_COORDS = { lat: 37.5665, lon: 126.9780 };

        const destinations = [
            { city: "오사카", country: "일본", lat: 34.6937, lon: 135.5023, desc: "먹방의 성지! 도톤보리 글리코상 앞에서 인증샷 필수." },
            { city: "후쿠오카", country: "일본", lat: 33.5902, lon: 130.4017, desc: "비행기로 1시간! 주말 밤도깨비 여행으로 완벽한 곳." },
            { city: "삿포로", country: "일본", lat: 43.0618, lon: 141.3545, desc: "겨울엔 눈축제, 여름엔 라벤더와 맥주가 기다리는 곳." },
            { city: "오키나와", country: "일본", lat: 26.2124, lon: 127.6809, desc: "동양의 하와이, 에메랄드빛 바다와 츄라우미 수족관." },
            { city: "교토", country: "일본", lat: 35.0116, lon: 135.7681, desc: "고즈넉한 사찰과 전통 거리를 거닐며 힐링하기." },
            { city: "도쿄", country: "일본", lat: 35.6762, lon: 139.6503, desc: "디즈니랜드, 쇼핑, 미식의 중심지." },
            { city: "타이베이", country: "대만", lat: 25.0320, lon: 121.5654, desc: "지우펀의 홍등과 스린 야시장의 먹거리 천국." },
            { city: "가오슝", country: "대만", lat: 22.6273, lon: 120.3014, desc: "대만의 부산! 예술특구와 항구 도시의 낭만." },
            { city: "홍콩", country: "중국", lat: 22.3193, lon: 114.1694, desc: "딤섬과 야경, 쇼핑을 사랑한다면 무조건 여기." },
            { city: "마카오", country: "중국", lat: 22.1987, lon: 113.5439, desc: "동양의 라스베이거스, 포르투갈 풍의 건축물." },
            { city: "상하이", country: "중국", lat: 31.2304, lon: 121.4737, desc: "와이탄의 화려한 야경과 디즈니랜드." },
            { city: "칭다오", country: "중국", lat: 36.0671, lon: 120.3826, desc: "양꼬치엔 칭다오! 맥주 박물관과 유럽풍 거리." },
            { city: "다낭", country: "베트남", lat: 16.0544, lon: 108.2022, desc: "한국인 최애 휴양지. 미케비치와 호이안 올드타운." },
            { city: "하노이", country: "베트남", lat: 21.0285, lon: 105.8542, desc: "천년의 역사, 쌀국수와 분짜의 본고장." },
            { city: "나트랑", country: "베트남", lat: 12.2388, lon: 109.1967, desc: "동양의 나폴리, 머드 온천과 빈펄 랜드." },
            { city: "방콕", country: "태국", lat: 13.7563, lon: 100.5018, desc: "배낭여행의 성지, 카오산로드와 화려한 왕궁." },
            { city: "치앙마이", country: "태국", lat: 18.7883, lon: 98.9853, desc: "디지털 노마드의 성지, 힙한 카페와 감성 여행." },
            { city: "세부", country: "필리핀", lat: 10.3157, lon: 123.8854, desc: "고래상어와 함께 수영을! 해양 액티비티 천국." },
            { city: "보홀", country: "필리핀", lat: 9.8500, lon: 124.1435, desc: "신비로운 초콜릿 힐과 안경원숭이, 다이빙의 성지." },
            { city: "보라카이", country: "필리핀", lat: 11.9674, lon: 121.9248, desc: "세계 3대 석양, 화이트 비치의 부드러운 모래." },
            { city: "코타키나발루", country: "말레이시아", lat: 5.9804, lon: 116.0753, desc: "황홀한 선셋과 반딧불 투어의 낭만." },
            { city: "비엔티안", country: "라오스", lat: 17.9757, lon: 102.6331, desc: "느림의 미학, 평화로운 불교 국가의 수도." },
            { city: "블라디보스토크", country: "러시아", lat: 43.1198, lon: 131.8869, desc: "가장 가까운 유럽. 킹크랩과 곰새우 파티!" },
            { city: "울란바토르", country: "몽골", lat: 47.9181, lon: 106.9176, desc: "드넓은 초원과 쏟아지는 별, 게르 체험." },
            { city: "괌", country: "미국", lat: 13.4443, lon: 144.7937, desc: "4시간 만에 가는 미국! 쇼핑과 휴양을 동시에." },
            { city: "사이판", country: "미국", lat: 15.1834, lon: 145.7468, desc: "마나가하섬의 투명한 바다와 별빛 투어." }
        ];

        let scene, camera, renderer;
        let earth, earthGroup, markerGroup, ring;
        let flightCurve, flightProgress = 0, isFlying = false, flightLine;
        
        const clock = new THREE.Clock();
        const textureLoader = new THREE.TextureLoader();

        const state = {
            isSpinning: false,
            isResultShown: false, 
            isDragging: false,
            isHovering: false,
            hoverTargetRotX: 0,
            hoverTargetRotY: 0,
            previousMousePosition: { x: 0, y: 0 },
            currentTarget: null,
            targetSceneX: 0
        };

        const API_ENDPOINT = '/api/picks';
        let pickCounts = {};

        function destinationKey(dest) {
            return `${dest.city}|${dest.country}`;
        }

        async function loadPickCounts() {
            const res = await fetch(API_ENDPOINT);
            if (!res.ok) throw new Error('Failed to load pick counts');
            return res.json();
        }

        async function incrementPickCount(dest) {
            const res = await fetch(API_ENDPOINT, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ city: dest.city, country: dest.country })
            });
            if (!res.ok) throw new Error('Failed to increment pick count');
            return res.json();
        }

        function getPickCount(dest) {
            const key = destinationKey(dest);
            return pickCounts[key] || 0;
        }

        const dom = {
            spinBtn: document.getElementById('spin-btn'),
            btnLoader: document.getElementById('btn-loader'),
            btnText: document.getElementById('btn-text'),
            resultCard: document.getElementById('result-card'),
            cityName: document.getElementById('city-name'),
            countryName: document.getElementById('country-name'),
            description: document.getElementById('description'),
            coords: document.getElementById('coords'),
            uiLayer: document.getElementById('ui-layer'),
            boardListContainer: document.getElementById('board-list-container'),
            rankListContainer: document.getElementById('rank-list-container'),
            destinationBoard: document.getElementById('destination-board'),
            cssPlane: document.getElementById('css-plane')
        };

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = CONFIG.cameraZ;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            renderer.outputEncoding = THREE.sRGBEncoding;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            setupLighting();
            createObjects();
            renderCandidateBoard();
            refreshRankBoard();
            setupEvents();
            animate();
        }

        function setupLighting() {
            scene.add(new THREE.AmbientLight(0xffffff, 0.3)); 
            const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
            sunLight.position.set(5, 3, 10);
            scene.add(sunLight);
            const backLight = new THREE.PointLight(0x5070ff, 0.5);
            backLight.position.set(-10, 0, -10);
            scene.add(backLight);
        }

        function createObjects() {
            // 1. 지구
            earthGroup = new THREE.Group();
            earthGroup.rotation.z = 23.5 * Math.PI / 180; 
            scene.add(earthGroup);

            const earthGeo = new THREE.SphereGeometry(CONFIG.earthRadius, 64, 64);
            const earthMat = new THREE.MeshStandardMaterial({
                map: textureLoader.load(CONFIG.textureUrl),
                roughness: 0.6,
                metalness: 0.1,
            });
            earth = new THREE.Mesh(earthGeo, earthMat);
            earthGroup.add(earth);

            // 2. 별 배경
            const starsGeo = new THREE.BufferGeometry();
            const count = 2000;
            const positions = new Float32Array(count * 3);
            for(let i = 0; i < count * 3; i++) {
                positions[i] = (Math.random() - 0.5) * 200;
            }
            starsGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const starsMat = new THREE.PointsMaterial({
                size: 0.15,
                color: 0xffffff,
                transparent: true,
                opacity: 0.8
            });
            const stars = new THREE.Points(starsGeo, starsMat);
            scene.add(stars);

            // 3. 마커 (핀)
            markerGroup = new THREE.Group();
            earth.add(markerGroup);
            markerGroup.visible = false;

            const pinMat = new THREE.MeshStandardMaterial({
                color: CONFIG.colors.pin,
                roughness: 0.3,
                metalness: 0.5,
                emissive: CONFIG.colors.pinEmissive,
                emissiveIntensity: 0.2
            });
            const pinStem = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.6, 8), pinMat);
            pinStem.position.y = 0.3;
            const pinHead = new THREE.Mesh(new THREE.SphereGeometry(0.15, 16, 16), pinMat);
            pinHead.position.y = 0.6;
            
            const fullMarker = new THREE.Group();
            fullMarker.add(pinStem);
            fullMarker.add(pinHead);
            
            const ringGeo = new THREE.RingGeometry(0.1, 0.15, 32);
            const ringMat = new THREE.MeshBasicMaterial({
                color: CONFIG.colors.pin,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.6
            });
            ring = new THREE.Mesh(ringGeo, ringMat);
            ring.rotation.x = Math.PI / 2;
            ring.position.y = 0.02;
            fullMarker.add(ring);
            markerGroup.add(fullMarker);
        }

        function renderCandidateBoard() {
            dom.boardListContainer.innerHTML = '';
            destinations.forEach(dest => {
                const item = document.createElement('div');
                item.className = 'board-item';
                item.innerHTML = `<span class="city">${dest.city}</span><span class="country">${dest.country}</span>`;
                
                // 호버 이벤트 추가
                item.addEventListener('mouseenter', () => onBoardItemHover(dest));
                item.addEventListener('mouseleave', onBoardItemLeave);
                
                dom.boardListContainer.appendChild(item);
            });
        }

        function renderRankBoard() {
            dom.rankListContainer.innerHTML = '';
            const sorted = destinations
                .slice()
                .sort((a, b) => {
                    const diff = getPickCount(b) - getPickCount(a);
                    if (diff !== 0) return diff;
                    return destinationKey(a).localeCompare(destinationKey(b));
                });

            sorted.forEach(dest => {
                const item = document.createElement('div');
                item.className = 'board-item';
                const count = getPickCount(dest);
                item.innerHTML = `<span class="city">${dest.city}</span><span class="country">${dest.country} · ${count}회</span>`;
                dom.rankListContainer.appendChild(item);
            });
        }

        async function refreshRankBoard() {
            try {
                pickCounts = await loadPickCounts();
            } catch {
                pickCounts = pickCounts || {};
            }
            renderRankBoard();
        }

        // 호버 시 호출될 함수
        function onBoardItemHover(dest) {
            // 뽑기 중이거나 결과 화면일 때는 호버 효과 무시
            if (state.isSpinning || state.isResultShown) return;

            state.isHovering = true;
            
            // 목표 회전각 계산 (startSpin 로직과 동일)
            const targetLatRad = dest.lat * (Math.PI / 180);
            const targetLonRad = -dest.lon * (Math.PI / 180);
            
            // 현재 회전값에 맞춰 최단 경로 계산
            const currentY = earth.rotation.y;
            let targetY = targetLonRad - Math.PI / 2;
            const twoPi = Math.PI * 2;
            
            // 현재 각도에서 가장 가까운 타겟 각도로 보정
            const diff = targetY - currentY;
            const cycles = Math.round(diff / twoPi);
            targetY -= cycles * twoPi;

            state.hoverTargetRotY = targetY;
            state.hoverTargetRotX = targetLatRad;

            // 마커 표시
            const targetPos = latLonToVector3(dest.lat, dest.lon, CONFIG.earthRadius);
            const fullMarker = markerGroup.children[0];
            fullMarker.position.copy(targetPos);
            fullMarker.lookAt(new THREE.Vector3(0,0,0));
            fullMarker.rotateX(-Math.PI / 2);
            
            markerGroup.visible = true;
        }

        function onBoardItemLeave() {
            if (state.isSpinning || state.isResultShown) return;
            
            state.isHovering = false;
            markerGroup.visible = false;
        }

        function setupEvents() {
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('mousedown', onPointerDown);
            document.addEventListener('touchstart', onPointerDown, {passive: false});
            document.addEventListener('mousemove', onPointerMove);
            document.addEventListener('touchmove', onPointerMove, {passive: false});
            document.addEventListener('mouseup', onPointerUp);
            document.addEventListener('touchend', onPointerUp);

            dom.spinBtn.addEventListener('click', () => {
                if (state.isResultShown) resetGame(); 
                else if (!state.isSpinning) startSpin(); 
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onPointerDown(e) {
            state.isDragging = true;
            const clientX = e.clientX || e.touches[0].clientX;
            const clientY = e.clientY || e.touches[0].clientY;
            state.previousMousePosition = { x: clientX, y: clientY };
        }

        function onPointerUp() { state.isDragging = false; }

        function onPointerMove(e) {
            if (state.isDragging && !state.isSpinning && !isFlying) {
                const clientX = e.clientX || e.touches[0].clientX;
                const clientY = e.clientY || e.touches[0].clientY;
                const deltaX = clientX - state.previousMousePosition.x;
                const deltaY = clientY - state.previousMousePosition.y;
                earth.rotation.y += deltaX * 0.005;
                earth.rotation.x += deltaY * 0.005;
                state.previousMousePosition = { x: clientX, y: clientY };
            }
        }

        // --- 로직: 회전 및 비행 ---
        function startSpin() {
            state.isSpinning = true;
            
            // UI 숨김
            dom.resultCard.classList.remove('show');
            dom.resultCard.classList.add('hidden');
            markerGroup.visible = false;
            dom.cssPlane.style.display = 'none'; // 비행기 숨김

            dom.btnLoader.style.display = 'block';
            dom.btnText.textContent = "좌표 계산 중...";
            dom.spinBtn.disabled = true;

            if (dom.destinationBoard) dom.destinationBoard.classList.add('slide-out');

            state.targetSceneX = 0;

            const randomIndex = Math.floor(Math.random() * destinations.length);
            state.currentTarget = destinations[randomIndex];

            const targetPos = latLonToVector3(state.currentTarget.lat, state.currentTarget.lon, CONFIG.earthRadius);
            const fullMarker = markerGroup.children[0]; 
            fullMarker.position.copy(targetPos);
            fullMarker.lookAt(new THREE.Vector3(0,0,0));
            fullMarker.rotateX(-Math.PI / 2); 

            // 목표 회전각 계산
            const targetLatRad = state.currentTarget.lat * (Math.PI / 180);
            const targetLonRad = -state.currentTarget.lon * (Math.PI / 180);
            const finalRotY = targetLonRad - Math.PI / 2;
            const finalRotX = targetLatRad;

            let speed = 0;
            let phase = 'accelerate'; 
            let startTime = performance.now();
            let fixedTargetY = null;
            
            function spinLoop(time) {
                if (!state.isSpinning) return;

                if (phase === 'accelerate') {
                    speed += CONFIG.acceleration;
                    if (speed >= CONFIG.maxSpinSpeed) speed = CONFIG.maxSpinSpeed;
                    earth.rotation.y += speed;
                    if (speed >= CONFIG.maxSpinSpeed) {
                        phase = 'constant';
                        startTime = time;
                    }
                } else if (phase === 'constant') {
                    earth.rotation.y += CONFIG.maxSpinSpeed;
                    if (time - startTime > 1000) { 
                        phase = 'decelerate';
                        const currentY = earth.rotation.y;
                        let targetY = finalRotY;
                        const twoPi = Math.PI * 2;
                        let n = Math.ceil((currentY - targetY) / twoPi);
                        targetY = targetY + (n * twoPi);
                        if (targetY - currentY < Math.PI * 1.5) { targetY += twoPi; }
                        fixedTargetY = targetY;
                    }
                } else if (phase === 'decelerate') {
                    earth.rotation.x = THREE.MathUtils.lerp(earth.rotation.x, finalRotX, 0.05);
                    earth.rotation.y = THREE.MathUtils.lerp(earth.rotation.y, fixedTargetY, 0.05);

                    if (Math.abs(earth.rotation.y - fixedTargetY) < 0.005 && Math.abs(earth.rotation.x - finalRotX) < 0.005) {
                        earth.rotation.y = fixedTargetY;
                        earth.rotation.x = finalRotX;
                        startFlightAnimation(); // 도착 후 비행
                        return; 
                    }
                }
                requestAnimationFrame(spinLoop);
            }
            requestAnimationFrame(spinLoop);
        }

        function startFlightAnimation() {
            state.isSpinning = false;
            
            // 경로 계산 (한국 -> 목적지)
            const startPos = latLonToVector3(KOREA_COORDS.lat, KOREA_COORDS.lon, CONFIG.earthRadius);
            const endPos = latLonToVector3(state.currentTarget.lat, state.currentTarget.lon, CONFIG.earthRadius);

            const distance = startPos.distanceTo(endPos);
            // 궤적 높이: 거리가 멀수록 높게
            const height = distance * 0.5 + 0.5; 
            const midPoint = startPos.clone().add(endPos).multiplyScalar(0.5).normalize().multiplyScalar(CONFIG.earthRadius + height);
            
            flightCurve = new THREE.QuadraticBezierCurve3(startPos, midPoint, endPos);
            
            // 3D 궤적 라인 그리기
            const points = flightCurve.getPoints(50);
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.6 });
            
            if (flightLine) {
                earth.remove(flightLine);
                flightLine.geometry.dispose();
            }
            flightLine = new THREE.Line(geometry, material);
            earth.add(flightLine);
            flightLine.visible = true;

            // 2D 비행기 보이기
            dom.cssPlane.style.display = 'block';
            
            flightProgress = 0;
            isFlying = true;
            dom.btnText.textContent = "여행지로 이동 중...";
        }

        function finishSpin() {
            // 도착 시 비행기 즉시 숨기기
            dom.cssPlane.style.display = 'none';
            
            isFlying = false;
            state.isResultShown = true; 
            markerGroup.visible = true;
            
            // 데스크톱일 경우 지구를 왼쪽으로 이동
            if (window.innerWidth >= 768) {
                state.targetSceneX = -3.5; // 작아진 지구에 맞춰 이동량 조정
            }

            dom.uiLayer.classList.add('result-mode');
            dom.btnLoader.style.display = 'none';
            dom.btnText.textContent = "🔄 초기화면으로";
            dom.spinBtn.disabled = false;

            dom.cityName.textContent = state.currentTarget.city;
            dom.countryName.textContent = state.currentTarget.country;
            dom.description.textContent = state.currentTarget.desc;
            dom.coords.textContent = `${state.currentTarget.lat}° N, ${state.currentTarget.lon}° E`;

            incrementPickCount(state.currentTarget)
                .then((counts) => {
                    pickCounts = counts;
                    renderRankBoard();
                })
                .catch(() => {});

            dom.resultCard.classList.remove('hidden');
            setTimeout(() => dom.resultCard.classList.add('show'), 50);
        }

        function resetGame() {
            state.isResultShown = false;
            state.targetSceneX = 0;
            
            dom.cssPlane.style.display = 'none'; // 비행기 숨김

            if (dom.destinationBoard) dom.destinationBoard.classList.remove('slide-out');
            
            dom.uiLayer.classList.remove('result-mode');
            dom.resultCard.classList.remove('show');
            setTimeout(() => {
                if(!state.isResultShown) dom.resultCard.classList.add('hidden');
            }, 500);

            markerGroup.visible = false;
            dom.btnText.textContent = "🎲 여행지 뽑기";
        }

        function latLonToVector3(lat, lon, radius) {
            const phi = (90 - lat) * (Math.PI / 180);
            const theta = (lon + 180) * (Math.PI / 180);
            const x = -(radius * Math.sin(phi) * Math.cos(theta));
            const z = (radius * Math.sin(phi) * Math.sin(theta));
            const y = (radius * Math.cos(phi));
            return new THREE.Vector3(x, y, z);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            scene.position.x = THREE.MathUtils.lerp(scene.position.x, state.targetSceneX, 0.05);

            if (!state.isSpinning && !state.isDragging && !state.isResultShown && !isFlying) {
                // 호버 중일 때는 타겟으로 부드럽게 회전, 아닐 때는 자동 회전
                if (state.isHovering) {
                    earth.rotation.y = THREE.MathUtils.lerp(earth.rotation.y, state.hoverTargetRotY, 0.1);
                    earth.rotation.x = THREE.MathUtils.lerp(earth.rotation.x, state.hoverTargetRotX, 0.1);
                } else {
                    earth.rotation.y += CONFIG.spinSpeed;
                    // X축 회전은 원래대로(0에 가깝게) 복구하거나 유지
                    earth.rotation.x = THREE.MathUtils.lerp(earth.rotation.x, 0, 0.05);
                }
            }

            // 비행 애니메이션 (2D CSS 이동)
            if (isFlying && flightCurve) {
                flightProgress += 0.015;
                if (flightProgress >= 1) {
                    flightProgress = 1;
                    isFlying = false;
                    finishSpin(); 
                }

                // 1. 현재 3D 위치
                const pointLocal = flightCurve.getPoint(flightProgress);
                // 2. 월드 좌표 변환
                const pointWorld = pointLocal.clone().applyMatrix4(earth.matrixWorld);
                // 3. 화면 좌표 변환
                const screenPos = pointWorld.clone().project(camera);
                const x = (screenPos.x * .5 + .5) * window.innerWidth;
                const y = (-(screenPos.y * .5) + .5) * window.innerHeight;

                // 4. CSS 위치 적용
                dom.cssPlane.style.left = `${x}px`;
                dom.cssPlane.style.top = `${y}px`;

                // 5. 회전 각도 계산 (다음 지점 방향)
                const nextPointLocal = flightCurve.getPoint(Math.min(flightProgress + 0.01, 1));
                const nextPointWorld = nextPointLocal.clone().applyMatrix4(earth.matrixWorld);
                const nextScreenPos = nextPointWorld.clone().project(camera);
                const nextX = (nextScreenPos.x * .5 + .5) * window.innerWidth;
                const nextY = (-(nextScreenPos.y * .5) + .5) * window.innerHeight;

                const deltaX = nextX - x;
                const deltaY = nextY - y;
                const angle = Math.atan2(deltaY, deltaX) * (180 / Math.PI);
                
                // [중요] 비행기 아이콘이 위쪽(North)을 보고 있다고 가정할 때,
                // 진행 방향(Right=0deg)에 맞추려면 90도를 더해야 머리가 앞을 봅니다.
                dom.cssPlane.style.transform = `translate(-50%, -50%) rotate(${angle + 90}deg)`; 
            }

            if (markerGroup.visible) {
                const s = 1 + Math.sin(time * 4) * 0.2;
                ring.scale.set(s, s, 1);
                ring.material.opacity = Math.max(0, 0.6 - (s - 1) * 2);
            }

            renderer.render(scene, camera);
        }

        init();

    </script>
</body>
</html>
